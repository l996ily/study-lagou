### 一、请说出下列最终的执行结果，并解释为什么

```js
var a = []
for (var i = 0; i< 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}
a[6]()//10
```

+ var 声明的变量只能是全局变量或局部(函数)变量
+ 因此在当前for循环中，声明了一个全局变量i
+ 而随着i循环，前面i的值将被后面新赋的值所替代，所以当i循环结束以后，当前i的值就是10了
+ 等着函数调用时，for循环已经执行完毕，而i的值为10， 所以函数调用的结果为10

### 二、请说出下列最终的执行结果，并解释为什么

```js
var tmp = 123;
if (true) {
  console.log(tmp) 
  // Cannot access 'tmp' before initialization
  let tmp
}
```

+ ES6以后，有了块级作用域，而let和const在{}内部声明的变量都属于块级作用域内部的
+ 而 let 和 const 是不允许变量提升的，所以会报上面的错误（在初始化之前无法访问'tmp'）。如果是var关键词的话，它就有变量提升，得到的值就是undefined

### 三、结合ES6新语法，用最简单的方式找出数组中的最小值

```js
var arr = [12,34,32,89,4]
```

```js
Math.min(...arr)
```

### 四、请详细说明var，let，const 三种声明变量的方式之间的具体差别

+ var 和 let、const 的差别
  + var 在全局声明的变量，会成为window的属性，而let和const不会

  + var 没有块级作用域，而let和const只要在{}下声明就会有块级作用域
  + var 可以变量提升，而let和cost不会，存在暂时性死区
  + var 声明了一个变量以后可以重复性声明，但是let和const也不行

+ let和const在拥有上面的共同特征，不过const有一些特殊的

  + 使用const声明时，必须同时进行赋值操作
  + const声明以后，不能重新指定新的内存地址，但原本内存地址中的属性才可以修改

### 五、请说出下列代码最终输出的结果，并解释为什么

```js
var a = 10;
var obj = {
  a:20,
  fn () {
    setTimeout(()=>{
      console.log(this.a)
    })
  }
}
obj.fn()//20
```

+ 箭头函数是没有自己的 this，它只会从自己的作用域链的上一层继承this，所以箭头函数的this是在创建的时候就已经确定了的
+ 从上面代码可以看出，定时器的回调函数是一个箭头函数，所以我们找其this指向，就应该在当前作用域链上往上一层查找，就找到了fn函数，所以当前箭头函数的this就指向fn函数
+ 又fn是普通函数，而普通函数的this是谁调用，那么this就指向谁。可以看到，代码的最后是obj对fn进行了调用，因此fn的this指向obj
+ 即最终定时器内部回调 `this.a`  ==> `obj.a` ==>20

### 六、简述 `symbol` 类型的用途

+ Symbol 是新增的基本数据类型，代表了当前数据的唯一性，可以保证在相同属性名的情况下也不会产生冲突
+ 可迭代对象上也使用到Symbol.iterator迭代器，将普通对象变为可迭代对象

### 七、说说什么是浅拷贝，什么是深拷贝

+ 浅拷贝：对于引用数据来说，他们会共用相同的内存地址，因此当其中一个变量内部的属性值改变了，另外一个变量内部的属性值也会随之改变

```js
let a = {
	name: 'zs',
	age: 18
}
let b = a 
b.name = 'andy'
console.log(a.name);//andy
```

+ 深拷贝：会重新开辟一个新的内存地址去存储值，所以当我任意改变了其中一个变量内部的属性值以后，另一个变量存储的数据时没有被改变的

### 八、请简述 TypeScript 与 Javascript 之间的关系

+ TypeScript 是 Javascript 的超集
+ 它包含了 Javascript 的所有元素，可以载入 Javascript 代码运行，并扩展了 Javascript 的语法

### 九、请你谈谈你所认为的 TypeScript 优缺点

+ 优点：
  + TypeScript 它的功能更加强大，生态也更加健全、更完善
  + TypeScript 最终会编译为 Javascript 语法，所以在任何一种 Javascript 运行环境下都支持
  + TypeScript 会使得代码更加规范，也更加严谨，便于多人的大型项目开发及后期维护
+ 缺点：
  + 在项目初期，TypeScript 会增加一些成本，因为要单独编写很多的类型。
  + 对于小型项目来说，TypeScript 的使用反而会增加一些工作量及开发成本

### 十、描述引用计数的工作原理和优缺点

+ 工作原理：设置引用数，判断当前引用数是否为0；当引用关系改变时修改引用数字，当引用数字为0时立即回收
+ 优点：
  + 发现垃圾时立即进行回收
  + 最大限度减少程序的暂停，内存空间是有限的，而引用计数是只要发现了为0的引用对象后，就会进行回收清理，就减少了程序的暂停
+ 缺点：
  + 无法回收循环引用的对象
  + 时间开销大：因为它会时刻的去监控当前引用对象数值的修改，而这就会造成时间的消耗

### 十一、描述标记整理算法的工作流程

+ 标记整理也分为两个阶段：分标记 和 清除 两个阶段
+ 遍历所有对象找到标记活动对象
+ 然后在清除阶段会先将所有的标记活动对象进行整理，移动对象位置，再执行清除

### 十二、描述 V8 中新生代存储区垃圾回收的流程

+ 新生代对象将内存空间分为两个等大小的空间，分别为使用空间 From，和空闲空间 To
+ 新生代对象会先存储在from空间，当一轮GC后，使用标记整理算法对from空间进行垃圾处理和空间内存优化，并将活动对象拷贝至 To
+ From 与 To 交互空间完成后释放

### 十三、描述增量标记算法在何时使用及工作原理

+ 何时使用：

  标记的过程中，js引擎不会执行代码，且老生代区域可存储的对象较多，当标记的对象太多的情况，可能会造成js执行卡顿的情况，但如果使用增量标记的方式，将标记拆分成多个小的部分，就可以较好的优化这种情况。

+ 工作原理：

  程序在执行的时候是不需要进行垃圾回收的，一旦触发了垃圾回收后，无论我们采用的是什么算法，都会进行一个遍历对象并标记的操作，而标记的动作不需要一次性做完，因为程序存在着直接可达和间接可达的操作。所以，在我们找到第一层的可达对象后，就可以将标记的动作停下来了，让我们的程序执行一会。程序执行一会后，又可以让我们的GC机制进行二次的标记操作。这样一个交替的做这两件事情。最后，标记完成以后，我们肯定是要去做这样一个垃圾回收了。而回收完成以后，程序又重新进行执行

